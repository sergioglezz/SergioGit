
[Docker](https://www.docker.com/) puede construir im√°genes autom√°ticamente leyendo las instrucciones de un [Dockerfile](Dockerfile). Un [Dockerfile](Dockerfile) es un documento de texto que contiene todos los comandos que un usuario podr√≠a llamar en la l√≠nea de comandos para montar una imagen. Usando `docker build` los usuarios pueden crear una construcci√≥n automatizada que ejecuta varias instrucciones de l√≠nea de comandos en sucesi√≥n.

## ü§∑ ¬øC√≥mo usarlo?

El comando `docker build` construye una imagen a partir de un [Dockerfile](Dockerfile) y un _contexto_. 

El _contexto_ de la construcci√≥n es el conjunto de archivos en una ubicaci√≥n especificada `PATH` o `URL`. El `PATH` es un directorio en tu sistema de archivos local. La `URL` es la ubicaci√≥n de un repositorio Git.

El contexto de construcci√≥n se procesa recursivamente. As√≠, un `PATH` incluye cualquier subdirectorio y la `URL` incluye el repositorio y sus subm√≥dulos. Este ejemplo muestra un comando de construcci√≥n que utiliza el directorio actual (`.`) como contexto de construcci√≥n:

```bash
$ docker build .

Sending build context to Docker daemon  6.51 MB
...
```

La construcci√≥n es ejecutada por el **demonio Docker**, no por la CLI. Lo primero que hace un proceso de construcci√≥n es enviar todo el contexto (recursivamente) al demonio. ¬¥

> üòä _En la mayor√≠a de los casos, es mejor empezar con un directorio vac√≠o como contexto y mantener tu [Dockerfile](Dockerfile) en ese directorio. A√±ade s√≥lo los archivos necesarios para construir el [Dockerfile](Dockerfile)._

> üî•**Advertencia**: _No utilice su directorio ra√≠z, `/`, como el `PATH` para su contexto de construcci√≥n, ya que hace que la construcci√≥n transfiera todo el contenido de su disco duro al **demonio Docker**._

Para utilizar un archivo en el contexto de construcci√≥n, el [Dockerfile](Dockerfile) se refiere al archivo especificado en una instrucci√≥n, por ejemplo, una instrucci√≥n `COPY`. Para aumentar el rendimiento de la compilaci√≥n, excluya archivos y directorios a√±adiendo un archivo [.dockerignore](.dockerignore) al directorio de contexto. Para obtener informaci√≥n sobre c√≥mo crear un archivo [.dockerignore](.dockerignore) consulte la documentaci√≥n de esta p√°gina.

> üòä _Tradicionalmente, el archivo Docker se llama [Dockerfile](Dockerfile) y se encuentra en la ra√≠z del contexto. Puedes usar la bandera `-f` con docker build para apuntar a un [Dockerfile](Dockerfile) en cualquier lugar de tu sistema de archivos._

```bash
$ docker build -f /path/to/a/Dockerfile .
```

Puedes especificar un repositorio y una etiqueta en la que guardar la nueva imagen si la construcci√≥n tiene √©xito:

```bash
$ docker build -t shykes/myapp .
```

Para etiquetar la imagen en varios repositorios despu√©s de la construcci√≥n, a√±ada varios par√°metros `-t` cuando ejecute el comando de construcci√≥n:

```bash
$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .
```

Antes de que el **demonio Docker** ejecute las instrucciones en el [Dockerfile](Dockerfile), realiza una validaci√≥n preliminar del [Dockerfile](Dockerfile) y devuelve un error si la sintaxis es incorrecta:

```bash
$ docker build -t test/myapp .

[+] Building 0.3s (2/2) FINISHED
 [internal] load build definition from Dockerfile                       0.1s
 => transferring dockerfile: 60B                                        0.0s
 [internal] load .dockerignore                                          0.1s
 => transferring context: 2B                                            0.0s
error: failed to solve: rpc error: code = Unknown desc = failed to solve with frontend dockerfile.v0: failed to create LLB definition:
dockerfile parse error line 2: unknown instruction: RUNCMD
```

El **demonio Docker** üòà ejecuta las instrucciones del [Dockerfile](Dockerfile) una por una, confirmando el resultado de cada instrucci√≥n en una nueva imagen si es necesario, antes de emitir finalmente el `ID` de su nueva imagen. El **demonio Docker** limpiar√° autom√°ticamente el contexto enviado.

Hay que tener cuenta que cada instrucci√≥n se ejecuta de forma independiente, y provoca la creaci√≥n de una nueva imagen - por lo que `RUN cd /tmp` no tendr√° ning√∫n efecto en las siguientes instrucciones.

Siempre que sea posible, [Docker](Docker) utiliza una cach√© de construcci√≥n para acelerar el proceso de construcci√≥n de Docker significativamente. Esto se indica con el mensaje `CACHED` en la salida de la consola. 

```bash
$ docker build -t svendowideit/ambassador .

[+] Building 0.7s (6/6) FINISHED
 [internal] load build definition from Dockerfile                       0.1s
 => transferring dockerfile: 286B                                       0.0s
 [internal] load .dockerignore                                          0.1s
 => transferring context: 2B                                            0.0s
 [internal] load metadata for docker.io/library/alpine:3.2              0.4s
 CACHED [1/2] FROM docker.io/library/alpine:3.2@sha256:e9a2035f9d0d7ce  0.0s
 CACHED [2/2] RUN apk add --no-cache socat                              0.0s
 exporting to image                                                     0.0s
 => exporting layers                                                    0.0s
 => writing image sha256:1affb80ca37018ac12067fa2af38cc5bcc2a8f09963de  0.0s
 => naming to docker.io/svendowideit/ambassador                         0.0s
```

Por defecto, la cach√© de construcci√≥n se basa en los resultados de construcciones anteriores en la m√°quina en la que se est√° construyendo. La opci√≥n `--cache-from` tambi√©n le permite utilizar una cach√© de construcci√≥n que se distribuye a trav√©s de un registro de im√°genes, consulte la secci√≥n de especificaci√≥n de fuentes de cach√© externas en la referencia del comando `docker build`.

Cuando hayas terminado con tu construcci√≥n, estar√°s listo para escanear tu imagen con docker scan, y empujar tu imagen a [Docker Hub]().

## üõ†Ô∏è BuildKit

A partir de la **versi√≥n 18.09**, [Docker](Docker) soporta un nuevo backend para ejecutar sus construcciones que es proporcionado por el proyecto [moby/buildkit](moby/buildkit). El backend BuildKit ofrece muchas ventajas en comparaci√≥n con la antigua implementaci√≥n. 

Por ejemplo, **BuildKit** puede:

* Detectar y omitir la ejecuci√≥n de etapas de construcci√≥n no utilizadas
* Paralelizar la construcci√≥n de etapas de construcci√≥n independientes
* Transferir de forma incremental s√≥lo los archivos modificados en su contexto de construcci√≥n entre construcciones
* Detectar y omitir la transferencia de archivos no utilizados en su contexto de construcci√≥n
* Utilizar implementaciones externas de Dockerfile con muchas caracter√≠sticas nuevas
* Evitar efectos secundarios con el resto de la API (im√°genes intermedias y contenedores)
* Dar prioridad a su cach√© de construcci√≥n para la poda autom√°tica

Para utilizar el backend BuildKit, es necesario establecer una variable de entorno `DOCKER_BUILDKIT=1` en la CLI antes de invocar `docker build`.

```bash
$ DOCKER_BUILDKIT=1 docker build .
```

> üìù **NOTA**: _Para habilitar docker BuildKit por defecto, establece la configuraci√≥n del demonio en [/etc/docker/daemon.json](/etc/docker/daemon.json) `feature` a `true` y reinicia el demonio:_ `{ "features": { "buildkit": true } }`

Para conocer la sintaxis experimental de [Dockerfile](Dockerfile) disponible para las construcciones basadas en **BuildKit**, consulta la documentaci√≥n en el repositorio de BuildKit.

## üìè Formato

Este es el formato del [Dockerfile](Dockerfile):

```dockerfile
# Comentario
<INSTRUCCI√ìN> argumentos
```

> üëÄ _Las instrucciones no distinguen entre may√∫sculas y min√∫sculas. Sin embargo, la convenci√≥n es que vayan en **MAY√öSCULAS** para distinguirlas de los argumentos m√°s f√°cilmente._

* Docker ejecuta las instrucciones de un Dockerfile en orden. 
* Un Dockerfile debe comenzar con una instrucci√≥n `FROM`. _Esto puede ser despu√©s de las directivas del parser, los comentarios y los ARGs de alcance global._ 

La instrucci√≥n `FROM` especifica la imagen padre desde la que se est√° construyendo. La instrucci√≥n `FROM` s√≥lo puede ir precedida de una o m√°s instrucciones `ARG`, que declaran los argumentos que se utilizan en las l√≠neas `FROM` del [Dockerfile](Dockerfile).

Docker trata las l√≠neas que comienzan con `#` como un comentario, a menos que la l√≠nea sea una directiva v√°lida del parser. Un marcador `#` en cualquier otro lugar de una l√≠nea es tratado como un argumento. Esto permite declaraciones como:

```dockerfile
# Comentario
RUN echo 'estamos ejecutando algunas # cosas geniales'
```

Las l√≠neas de comentario se eliminan antes de que se ejecuten las instrucciones del [Dockerfile](Dockerfile), lo que significa que el comentario en el siguiente ejemplo no es manejado por el shell que ejecuta el comando `echo`, y ambos ejemplos son equivalentes:

```dockerfile
RUN echo hola \
# comentario
mundo
```
```dockerfile
RUN echo hola \
mundo
```

> üî• _Los caracteres de continuaci√≥n de l√≠nea no son compatibles con los comentarios._

## üëå Buenas pr√°cticas al crear un Dockerfile

* **Los contenedores deber ser "ef√≠meros"** Cuando decimos "ef√≠meros" queremos decir que la creaci√≥n, parada, despliegue de los contenedores creados a partir de la imagen que vamos a generar con nuestro Dockerfile debe tener una m√≠nima configuraci√≥n.

* **Uso de ficheros [.dockerignore](.dockerignore)** Como hemos indicado anteriormente, todos los ficheros del contexto se env√≠an al docker engine, es recomendable usar un directorio vac√≠o donde vamos creando los ficheros que vamos a enviar. Adem√°s, para aumentar el rendimiento, y no enviar al daemon ficheros innecesarios podemos hacer uso de un fichero [.dockerignore](.dockerignore), para excluir ficheros y directorios.

* **No instalar paquetes innecesarios** Para reducir la complejidad, dependencias, tiempo de creaci√≥n y tama√±o de la imagen resultante, se debe evitar instalar paquetes extras o innecesarios Si alg√∫n paquete es necesario durante la creaci√≥n de la imagen, lo mejor es desinstalarlo durante el proceso.

* **Minimizar el n√∫mero de capas** Debemos encontrar el balance entre la legibilidad del Dockerfile y minimizar el n√∫mero de capa que utiliza.

* **Indicar las instrucciones a ejecutar en m√∫ltiples l√≠neas** Cada vez que sea posible y para hacer m√°s f√°cil futuros cambios, hay que organizar los argumentos de las instrucciones que contengan m√∫ltiples l√≠neas, esto evitar√° la duplicaci√≥n de paquetes y har√° que el archivo sea m√°s f√°cil de leer. Por ejemplo:

```bash
RUN apt-get update && apt-get install -y \
git \
wget \
apache2 \
php5
```